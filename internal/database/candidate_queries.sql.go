// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: candidate_queries.sql

package database

import (
	"context"
	"database/sql"
	"time"
)

const addCandidateCategory = `-- name: AddCandidateCategory :one
INSERT INTO candidate_categories (
  id,
  created_at,
  updated_at,
  candidate_id,
  arxiv_category
) VALUES (
  ?, ?, ?, ?, ?
)
RETURNING id, created_at, updated_at, candidate_id, arxiv_category
`

type AddCandidateCategoryParams struct {
	ID            interface{}
	CreatedAt     time.Time
	UpdatedAt     time.Time
	CandidateID   interface{}
	ArxivCategory string
}

func (q *Queries) AddCandidateCategory(ctx context.Context, arg AddCandidateCategoryParams) (CandidateCategory, error) {
	row := q.db.QueryRowContext(ctx, addCandidateCategory,
		arg.ID,
		arg.CreatedAt,
		arg.UpdatedAt,
		arg.CandidateID,
		arg.ArxivCategory,
	)
	var i CandidateCategory
	err := row.Scan(
		&i.ID,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.CandidateID,
		&i.ArxivCategory,
	)
	return i, err
}

const checkCandidateExists = `-- name: CheckCandidateExists :one
SELECT EXISTS (
  SELECT 1 FROM candidates
  WHERE linkedin_url = ? OR github_url = ? OR name = ?
) AS candidate_exists
`

type CheckCandidateExistsParams struct {
	LinkedinUrl sql.NullString
	GithubUrl   sql.NullString
	Name        string
}

func (q *Queries) CheckCandidateExists(ctx context.Context, arg CheckCandidateExistsParams) (int64, error) {
	row := q.db.QueryRowContext(ctx, checkCandidateExists, arg.LinkedinUrl, arg.GithubUrl, arg.Name)
	var candidate_exists int64
	err := row.Scan(&candidate_exists)
	return candidate_exists, err
}

const createCandidate = `-- name: CreateCandidate :one
INSERT INTO candidates (
  id,
  created_at,
  updated_at,
  name,
  linkedin_url,
  github_url
) VALUES (
  ?, ?, ?, ?, ?, ?
)
RETURNING id, created_at, updated_at, name, linkedin_url, github_url
`

type CreateCandidateParams struct {
	ID          interface{}
	CreatedAt   time.Time
	UpdatedAt   time.Time
	Name        string
	LinkedinUrl sql.NullString
	GithubUrl   sql.NullString
}

func (q *Queries) CreateCandidate(ctx context.Context, arg CreateCandidateParams) (Candidate, error) {
	row := q.db.QueryRowContext(ctx, createCandidate,
		arg.ID,
		arg.CreatedAt,
		arg.UpdatedAt,
		arg.Name,
		arg.LinkedinUrl,
		arg.GithubUrl,
	)
	var i Candidate
	err := row.Scan(
		&i.ID,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.Name,
		&i.LinkedinUrl,
		&i.GithubUrl,
	)
	return i, err
}

const deleteCandidateCategory = `-- name: DeleteCandidateCategory :exec
DELETE FROM candidate_categories
WHERE candidate_id = ? AND arxiv_category = ?
`

type DeleteCandidateCategoryParams struct {
	CandidateID   interface{}
	ArxivCategory string
}

func (q *Queries) DeleteCandidateCategory(ctx context.Context, arg DeleteCandidateCategoryParams) error {
	_, err := q.db.ExecContext(ctx, deleteCandidateCategory, arg.CandidateID, arg.ArxivCategory)
	return err
}

const findCandidateByName = `-- name: FindCandidateByName :many
SELECT id, created_at, updated_at, name, linkedin_url, github_url FROM candidates
WHERE LOWER(name) LIKE LOWER('%' || ? || '%')
ORDER BY created_at DESC
LIMIT ?
OFFSET ?
`

type FindCandidateByNameParams struct {
	Column1 sql.NullString
	Limit   int64
	Offset  int64
}

func (q *Queries) FindCandidateByName(ctx context.Context, arg FindCandidateByNameParams) ([]Candidate, error) {
	rows, err := q.db.QueryContext(ctx, findCandidateByName, arg.Column1, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Candidate
	for rows.Next() {
		var i Candidate
		if err := rows.Scan(
			&i.ID,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.Name,
			&i.LinkedinUrl,
			&i.GithubUrl,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getCandidateWithCategories = `-- name: GetCandidateWithCategories :many
SELECT 
  c.id, c.created_at, c.updated_at, c.name, c.linkedin_url, c.github_url,
  cc.arxiv_category
FROM candidates c
LEFT JOIN candidate_categories cc ON c.id = cc.candidate_id
WHERE c.id = ?
`

type GetCandidateWithCategoriesRow struct {
	ID            interface{}
	CreatedAt     time.Time
	UpdatedAt     time.Time
	Name          string
	LinkedinUrl   sql.NullString
	GithubUrl     sql.NullString
	ArxivCategory sql.NullString
}

func (q *Queries) GetCandidateWithCategories(ctx context.Context, id interface{}) ([]GetCandidateWithCategoriesRow, error) {
	rows, err := q.db.QueryContext(ctx, getCandidateWithCategories, id)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetCandidateWithCategoriesRow
	for rows.Next() {
		var i GetCandidateWithCategoriesRow
		if err := rows.Scan(
			&i.ID,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.Name,
			&i.LinkedinUrl,
			&i.GithubUrl,
			&i.ArxivCategory,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getCandidatesByCategory = `-- name: GetCandidatesByCategory :many
SELECT 
  c.id, c.created_at, c.updated_at, c.name, c.linkedin_url, c.github_url
FROM candidates c
JOIN candidate_categories cc ON c.id = cc.candidate_id
WHERE cc.arxiv_category = ?
ORDER BY c.created_at DESC
LIMIT ?
OFFSET ?
`

type GetCandidatesByCategoryParams struct {
	ArxivCategory string
	Limit         int64
	Offset        int64
}

func (q *Queries) GetCandidatesByCategory(ctx context.Context, arg GetCandidatesByCategoryParams) ([]Candidate, error) {
	rows, err := q.db.QueryContext(ctx, getCandidatesByCategory, arg.ArxivCategory, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Candidate
	for rows.Next() {
		var i Candidate
		if err := rows.Scan(
			&i.ID,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.Name,
			&i.LinkedinUrl,
			&i.GithubUrl,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const linkCandidateToSearch = `-- name: LinkCandidateToSearch :one
INSERT INTO candidate_searches (
  id,
  created_at,
  updated_at,
  candidate_id,
  search_id,
  relevance_score,
  notes
) VALUES (
  ?, ?, ?, ?, ?, ?, ?
)
RETURNING id, created_at, updated_at, candidate_id, search_id, relevance_score, notes
`

type LinkCandidateToSearchParams struct {
	ID             interface{}
	CreatedAt      time.Time
	UpdatedAt      time.Time
	CandidateID    interface{}
	SearchID       interface{}
	RelevanceScore sql.NullFloat64
	Notes          sql.NullString
}

func (q *Queries) LinkCandidateToSearch(ctx context.Context, arg LinkCandidateToSearchParams) (CandidateSearch, error) {
	row := q.db.QueryRowContext(ctx, linkCandidateToSearch,
		arg.ID,
		arg.CreatedAt,
		arg.UpdatedAt,
		arg.CandidateID,
		arg.SearchID,
		arg.RelevanceScore,
		arg.Notes,
	)
	var i CandidateSearch
	err := row.Scan(
		&i.ID,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.CandidateID,
		&i.SearchID,
		&i.RelevanceScore,
		&i.Notes,
	)
	return i, err
}

const listCandidatesBySearch = `-- name: ListCandidatesBySearch :many
SELECT 
  c.id, c.created_at, c.updated_at, c.name, c.linkedin_url, c.github_url,
  cs.relevance_score,
  cs.notes
FROM candidates c
JOIN candidate_searches cs ON c.id = cs.candidate_id
WHERE cs.search_id = ?
ORDER BY cs.relevance_score DESC
LIMIT ?
OFFSET ?
`

type ListCandidatesBySearchParams struct {
	SearchID interface{}
	Limit    int64
	Offset   int64
}

type ListCandidatesBySearchRow struct {
	ID             interface{}
	CreatedAt      time.Time
	UpdatedAt      time.Time
	Name           string
	LinkedinUrl    sql.NullString
	GithubUrl      sql.NullString
	RelevanceScore sql.NullFloat64
	Notes          sql.NullString
}

func (q *Queries) ListCandidatesBySearch(ctx context.Context, arg ListCandidatesBySearchParams) ([]ListCandidatesBySearchRow, error) {
	rows, err := q.db.QueryContext(ctx, listCandidatesBySearch, arg.SearchID, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListCandidatesBySearchRow
	for rows.Next() {
		var i ListCandidatesBySearchRow
		if err := rows.Scan(
			&i.ID,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.Name,
			&i.LinkedinUrl,
			&i.GithubUrl,
			&i.RelevanceScore,
			&i.Notes,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateCandidate = `-- name: UpdateCandidate :one
UPDATE candidates
SET 
  updated_at = ?,
  name = ?,
  linkedin_url = ?,
  github_url = ?
WHERE id = ?
RETURNING id, created_at, updated_at, name, linkedin_url, github_url
`

type UpdateCandidateParams struct {
	UpdatedAt   time.Time
	Name        string
	LinkedinUrl sql.NullString
	GithubUrl   sql.NullString
	ID          interface{}
}

func (q *Queries) UpdateCandidate(ctx context.Context, arg UpdateCandidateParams) (Candidate, error) {
	row := q.db.QueryRowContext(ctx, updateCandidate,
		arg.UpdatedAt,
		arg.Name,
		arg.LinkedinUrl,
		arg.GithubUrl,
		arg.ID,
	)
	var i Candidate
	err := row.Scan(
		&i.ID,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.Name,
		&i.LinkedinUrl,
		&i.GithubUrl,
	)
	return i, err
}

const updateCandidateRelevance = `-- name: UpdateCandidateRelevance :one
UPDATE candidate_searches
SET
  updated_at = ?,
  relevance_score = ?,
  notes = ?
WHERE candidate_id = ? AND search_id = ?
RETURNING id, created_at, updated_at, candidate_id, search_id, relevance_score, notes
`

type UpdateCandidateRelevanceParams struct {
	UpdatedAt      time.Time
	RelevanceScore sql.NullFloat64
	Notes          sql.NullString
	CandidateID    interface{}
	SearchID       interface{}
}

func (q *Queries) UpdateCandidateRelevance(ctx context.Context, arg UpdateCandidateRelevanceParams) (CandidateSearch, error) {
	row := q.db.QueryRowContext(ctx, updateCandidateRelevance,
		arg.UpdatedAt,
		arg.RelevanceScore,
		arg.Notes,
		arg.CandidateID,
		arg.SearchID,
	)
	var i CandidateSearch
	err := row.Scan(
		&i.ID,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.CandidateID,
		&i.SearchID,
		&i.RelevanceScore,
		&i.Notes,
	)
	return i, err
}
