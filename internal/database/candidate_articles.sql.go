// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: candidate_articles.sql

package database

import (
	"context"
	"database/sql"
	"time"
)

const checkArticleCandidateLinkExists = `-- name: CheckArticleCandidateLinkExists :one
SELECT EXISTS (
  SELECT 1 FROM candidate_articles
  WHERE candidate_id = ? AND article_id = ?
) AS link_exists
`

type CheckArticleCandidateLinkExistsParams struct {
	CandidateID interface{}
	ArticleID   interface{}
}

func (q *Queries) CheckArticleCandidateLinkExists(ctx context.Context, arg CheckArticleCandidateLinkExistsParams) (int64, error) {
	row := q.db.QueryRowContext(ctx, checkArticleCandidateLinkExists, arg.CandidateID, arg.ArticleID)
	var link_exists int64
	err := row.Scan(&link_exists)
	return link_exists, err
}

const getArticlesByCandidate = `-- name: GetArticlesByCandidate :many
SELECT 
  a.id, a.fetched_at, a.article_url, a.article_title, a.article_summary, a.article_authors, a.search_id,
  ca.created_at as discovery_date
FROM articles a
JOIN candidate_articles ca ON a.id = ca.article_id
WHERE ca.candidate_id = ?
ORDER BY ca.created_at DESC
`

type GetArticlesByCandidateRow struct {
	ID             interface{}
	FetchedAt      time.Time
	ArticleUrl     string
	ArticleTitle   string
	ArticleSummary string
	ArticleAuthors string
	SearchID       interface{}
	DiscoveryDate  time.Time
}

func (q *Queries) GetArticlesByCandidate(ctx context.Context, candidateID interface{}) ([]GetArticlesByCandidateRow, error) {
	rows, err := q.db.QueryContext(ctx, getArticlesByCandidate, candidateID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetArticlesByCandidateRow
	for rows.Next() {
		var i GetArticlesByCandidateRow
		if err := rows.Scan(
			&i.ID,
			&i.FetchedAt,
			&i.ArticleUrl,
			&i.ArticleTitle,
			&i.ArticleSummary,
			&i.ArticleAuthors,
			&i.SearchID,
			&i.DiscoveryDate,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getCandidateDiscoveryArticles = `-- name: GetCandidateDiscoveryArticles :many
SELECT
  a.id, a.fetched_at, a.article_url, a.article_title, a.article_summary, a.article_authors, a.search_id,
  s.description as search_description,
  ca.created_at as discovery_date
FROM candidate_articles ca
JOIN articles a ON ca.article_id = a.id
JOIN searches s ON a.search_id = s.id
WHERE ca.candidate_id = ?
ORDER BY ca.created_at DESC
`

type GetCandidateDiscoveryArticlesRow struct {
	ID                interface{}
	FetchedAt         time.Time
	ArticleUrl        string
	ArticleTitle      string
	ArticleSummary    string
	ArticleAuthors    string
	SearchID          interface{}
	SearchDescription string
	DiscoveryDate     time.Time
}

func (q *Queries) GetCandidateDiscoveryArticles(ctx context.Context, candidateID interface{}) ([]GetCandidateDiscoveryArticlesRow, error) {
	rows, err := q.db.QueryContext(ctx, getCandidateDiscoveryArticles, candidateID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetCandidateDiscoveryArticlesRow
	for rows.Next() {
		var i GetCandidateDiscoveryArticlesRow
		if err := rows.Scan(
			&i.ID,
			&i.FetchedAt,
			&i.ArticleUrl,
			&i.ArticleTitle,
			&i.ArticleSummary,
			&i.ArticleAuthors,
			&i.SearchID,
			&i.SearchDescription,
			&i.DiscoveryDate,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getCandidatesByArticle = `-- name: GetCandidatesByArticle :many
SELECT 
  c.id, c.created_at, c.updated_at, c.name, c.linkedin_url, c.github_url,
  ca.created_at as discovery_date
FROM candidates c
JOIN candidate_articles ca ON c.id = ca.candidate_id
WHERE ca.article_id = ?
ORDER BY ca.created_at DESC
`

type GetCandidatesByArticleRow struct {
	ID            interface{}
	CreatedAt     time.Time
	UpdatedAt     time.Time
	Name          string
	LinkedinUrl   sql.NullString
	GithubUrl     sql.NullString
	DiscoveryDate time.Time
}

func (q *Queries) GetCandidatesByArticle(ctx context.Context, articleID interface{}) ([]GetCandidatesByArticleRow, error) {
	rows, err := q.db.QueryContext(ctx, getCandidatesByArticle, articleID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetCandidatesByArticleRow
	for rows.Next() {
		var i GetCandidatesByArticleRow
		if err := rows.Scan(
			&i.ID,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.Name,
			&i.LinkedinUrl,
			&i.GithubUrl,
			&i.DiscoveryDate,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const linkArticleToCandidate = `-- name: LinkArticleToCandidate :one
INSERT INTO candidate_articles (
  id,
  created_at,
  updated_at,
  candidate_id,
  article_id
) VALUES (
  ?, ?, ?, ?, ?
)
RETURNING id, created_at, updated_at, candidate_id, article_id
`

type LinkArticleToCandidateParams struct {
	ID          interface{}
	CreatedAt   time.Time
	UpdatedAt   time.Time
	CandidateID interface{}
	ArticleID   interface{}
}

func (q *Queries) LinkArticleToCandidate(ctx context.Context, arg LinkArticleToCandidateParams) (CandidateArticle, error) {
	row := q.db.QueryRowContext(ctx, linkArticleToCandidate,
		arg.ID,
		arg.CreatedAt,
		arg.UpdatedAt,
		arg.CandidateID,
		arg.ArticleID,
	)
	var i CandidateArticle
	err := row.Scan(
		&i.ID,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.CandidateID,
		&i.ArticleID,
	)
	return i, err
}

const unlinkArticleFromCandidate = `-- name: UnlinkArticleFromCandidate :exec
DELETE FROM candidate_articles
WHERE candidate_id = ? AND article_id = ?
`

type UnlinkArticleFromCandidateParams struct {
	CandidateID interface{}
	ArticleID   interface{}
}

func (q *Queries) UnlinkArticleFromCandidate(ctx context.Context, arg UnlinkArticleFromCandidateParams) error {
	_, err := q.db.ExecContext(ctx, unlinkArticleFromCandidate, arg.CandidateID, arg.ArticleID)
	return err
}
