// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: search_queries.sql

package database

import (
	"context"
	"database/sql"
	"time"
)

const createSearch = `-- name: CreateSearch :one
INSERT INTO searches (
  id, 
  created_at, 
  updated_at, 
  description, 
  arvix_url, 
  results_per_fetch,
  last_fetch_date
) VALUES (
  ?, ?, ?, ?, ?, ?, ?
)
RETURNING id, created_at, updated_at, description, arvix_url, results_per_fetch, last_fetch_date
`

type CreateSearchParams struct {
	ID              interface{}
	CreatedAt       time.Time
	UpdatedAt       time.Time
	Description     string
	ArvixUrl        string
	ResultsPerFetch sql.NullInt64
	LastFetchDate   sql.NullTime
}

func (q *Queries) CreateSearch(ctx context.Context, arg CreateSearchParams) (Search, error) {
	row := q.db.QueryRowContext(ctx, createSearch,
		arg.ID,
		arg.CreatedAt,
		arg.UpdatedAt,
		arg.Description,
		arg.ArvixUrl,
		arg.ResultsPerFetch,
		arg.LastFetchDate,
	)
	var i Search
	err := row.Scan(
		&i.ID,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.Description,
		&i.ArvixUrl,
		&i.ResultsPerFetch,
		&i.LastFetchDate,
	)
	return i, err
}

const decrementSearchFetchResults = `-- name: DecrementSearchFetchResults :one
UPDATE searches
SET
  updated_at = ?,
  results_per_fetch = MAX(results_per_fetch - ?, 10)
WHERE id = ?
RETURNING id, created_at, updated_at, description, arvix_url, results_per_fetch, last_fetch_date
`

type DecrementSearchFetchResultsParams struct {
	UpdatedAt       time.Time
	ResultsPerFetch sql.NullInt64
	ID              interface{}
}

func (q *Queries) DecrementSearchFetchResults(ctx context.Context, arg DecrementSearchFetchResultsParams) (Search, error) {
	row := q.db.QueryRowContext(ctx, decrementSearchFetchResults, arg.UpdatedAt, arg.ResultsPerFetch, arg.ID)
	var i Search
	err := row.Scan(
		&i.ID,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.Description,
		&i.ArvixUrl,
		&i.ResultsPerFetch,
		&i.LastFetchDate,
	)
	return i, err
}

const deleteSearch = `-- name: DeleteSearch :exec
DELETE FROM searches
WHERE id = ?
`

func (q *Queries) DeleteSearch(ctx context.Context, id interface{}) error {
	_, err := q.db.ExecContext(ctx, deleteSearch, id)
	return err
}

const getLatestFetchTime = `-- name: GetLatestFetchTime :one
SELECT MAX(fetched_at) as latest_fetch
FROM articles
WHERE search_id = ?
`

func (q *Queries) GetLatestFetchTime(ctx context.Context, searchID interface{}) (interface{}, error) {
	row := q.db.QueryRowContext(ctx, getLatestFetchTime, searchID)
	var latest_fetch interface{}
	err := row.Scan(&latest_fetch)
	return latest_fetch, err
}

const getSearchByID = `-- name: GetSearchByID :one
SELECT id, created_at, updated_at, description, arvix_url, results_per_fetch, last_fetch_date FROM searches
WHERE id = ?
LIMIT 1
`

func (q *Queries) GetSearchByID(ctx context.Context, id interface{}) (Search, error) {
	row := q.db.QueryRowContext(ctx, getSearchByID, id)
	var i Search
	err := row.Scan(
		&i.ID,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.Description,
		&i.ArvixUrl,
		&i.ResultsPerFetch,
		&i.LastFetchDate,
	)
	return i, err
}

const getSearchWithStats = `-- name: GetSearchWithStats :one
SELECT 
  s.id, s.created_at, s.updated_at, s.description, s.arvix_url, s.results_per_fetch, s.last_fetch_date,
  COUNT(DISTINCT a.id) AS article_count,
  COUNT(DISTINCT cs.candidate_id) AS candidate_count,
  s.last_fetch_date,
  MIN(a.fetched_at) AS first_fetch_time
FROM searches s
LEFT JOIN articles a ON s.id = a.search_id
LEFT JOIN candidate_searches cs ON s.id = cs.search_id
WHERE s.id = ?
GROUP BY s.id
`

type GetSearchWithStatsRow struct {
	ID              interface{}
	CreatedAt       time.Time
	UpdatedAt       time.Time
	Description     string
	ArvixUrl        string
	ResultsPerFetch sql.NullInt64
	LastFetchDate   sql.NullTime
	ArticleCount    int64
	CandidateCount  int64
	LastFetchDate_2 sql.NullTime
	FirstFetchTime  interface{}
}

func (q *Queries) GetSearchWithStats(ctx context.Context, id interface{}) (GetSearchWithStatsRow, error) {
	row := q.db.QueryRowContext(ctx, getSearchWithStats, id)
	var i GetSearchWithStatsRow
	err := row.Scan(
		&i.ID,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.Description,
		&i.ArvixUrl,
		&i.ResultsPerFetch,
		&i.LastFetchDate,
		&i.ArticleCount,
		&i.CandidateCount,
		&i.LastFetchDate_2,
		&i.FirstFetchTime,
	)
	return i, err
}

const getSearchesByArxivCategory = `-- name: GetSearchesByArxivCategory :many
SELECT s.id, s.created_at, s.updated_at, s.description, s.arvix_url, s.results_per_fetch, s.last_fetch_date
FROM searches s
WHERE s.arvix_url LIKE '%' || ? || '%'
ORDER BY s.created_at DESC
`

func (q *Queries) GetSearchesByArxivCategory(ctx context.Context, dollar_1 sql.NullString) ([]Search, error) {
	rows, err := q.db.QueryContext(ctx, getSearchesByArxivCategory, dollar_1)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Search
	for rows.Next() {
		var i Search
		if err := rows.Scan(
			&i.ID,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.Description,
			&i.ArvixUrl,
			&i.ResultsPerFetch,
			&i.LastFetchDate,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getSearchesWithoutRecentFetches = `-- name: GetSearchesWithoutRecentFetches :many
SELECT s.id, s.created_at, s.updated_at, s.description, s.arvix_url, s.results_per_fetch, s.last_fetch_date
FROM searches s
WHERE s.last_fetch_date IS NULL OR s.last_fetch_date < ?
ORDER BY 
  CASE WHEN s.last_fetch_date IS NULL THEN 0 ELSE 1 END ASC,
  s.last_fetch_date ASC
LIMIT ?
`

type GetSearchesWithoutRecentFetchesParams struct {
	LastFetchDate sql.NullTime
	Limit         int64
}

func (q *Queries) GetSearchesWithoutRecentFetches(ctx context.Context, arg GetSearchesWithoutRecentFetchesParams) ([]Search, error) {
	rows, err := q.db.QueryContext(ctx, getSearchesWithoutRecentFetches, arg.LastFetchDate, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Search
	for rows.Next() {
		var i Search
		if err := rows.Scan(
			&i.ID,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.Description,
			&i.ArvixUrl,
			&i.ResultsPerFetch,
			&i.LastFetchDate,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const incrementSearchFetchResults = `-- name: IncrementSearchFetchResults :one
UPDATE searches
SET
  updated_at = ?,
  results_per_fetch = MIN(results_per_fetch + ?, 1999)
WHERE id = ?
RETURNING id, created_at, updated_at, description, arvix_url, results_per_fetch, last_fetch_date
`

type IncrementSearchFetchResultsParams struct {
	UpdatedAt       time.Time
	ResultsPerFetch sql.NullInt64
	ID              interface{}
}

func (q *Queries) IncrementSearchFetchResults(ctx context.Context, arg IncrementSearchFetchResultsParams) (Search, error) {
	row := q.db.QueryRowContext(ctx, incrementSearchFetchResults, arg.UpdatedAt, arg.ResultsPerFetch, arg.ID)
	var i Search
	err := row.Scan(
		&i.ID,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.Description,
		&i.ArvixUrl,
		&i.ResultsPerFetch,
		&i.LastFetchDate,
	)
	return i, err
}

const listActiveSearches = `-- name: ListActiveSearches :many
SELECT 
  s.id, s.created_at, s.updated_at, s.description, s.arvix_url, s.results_per_fetch, s.last_fetch_date,
  COUNT(a.id) AS article_count
FROM searches s
LEFT JOIN articles a ON s.id = a.search_id
GROUP BY s.id
ORDER BY CASE WHEN s.last_fetch_date IS NULL THEN 0 ELSE 1 END DESC, s.last_fetch_date DESC, s.created_at DESC
LIMIT ?
OFFSET ?
`

type ListActiveSearchesParams struct {
	Limit  int64
	Offset int64
}

type ListActiveSearchesRow struct {
	ID              interface{}
	CreatedAt       time.Time
	UpdatedAt       time.Time
	Description     string
	ArvixUrl        string
	ResultsPerFetch sql.NullInt64
	LastFetchDate   sql.NullTime
	ArticleCount    int64
}

func (q *Queries) ListActiveSearches(ctx context.Context, arg ListActiveSearchesParams) ([]ListActiveSearchesRow, error) {
	rows, err := q.db.QueryContext(ctx, listActiveSearches, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListActiveSearchesRow
	for rows.Next() {
		var i ListActiveSearchesRow
		if err := rows.Scan(
			&i.ID,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.Description,
			&i.ArvixUrl,
			&i.ResultsPerFetch,
			&i.LastFetchDate,
			&i.ArticleCount,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listAllSearches = `-- name: ListAllSearches :many
SELECT id, created_at, updated_at, description, arvix_url, results_per_fetch, last_fetch_date FROM searches
ORDER BY created_at DESC
`

func (q *Queries) ListAllSearches(ctx context.Context) ([]Search, error) {
	rows, err := q.db.QueryContext(ctx, listAllSearches)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Search
	for rows.Next() {
		var i Search
		if err := rows.Scan(
			&i.ID,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.Description,
			&i.ArvixUrl,
			&i.ResultsPerFetch,
			&i.LastFetchDate,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listRecentSearches = `-- name: ListRecentSearches :many
SELECT id, created_at, updated_at, description, arvix_url, results_per_fetch, last_fetch_date FROM searches
ORDER BY updated_at DESC
LIMIT ?
`

func (q *Queries) ListRecentSearches(ctx context.Context, limit int64) ([]Search, error) {
	rows, err := q.db.QueryContext(ctx, listRecentSearches, limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Search
	for rows.Next() {
		var i Search
		if err := rows.Scan(
			&i.ID,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.Description,
			&i.ArvixUrl,
			&i.ResultsPerFetch,
			&i.LastFetchDate,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const searchByDescription = `-- name: SearchByDescription :many
SELECT id, created_at, updated_at, description, arvix_url, results_per_fetch, last_fetch_date
FROM searches
WHERE LOWER(description) LIKE LOWER('%' || ? || '%')
ORDER BY created_at DESC
`

func (q *Queries) SearchByDescription(ctx context.Context, dollar_1 sql.NullString) ([]Search, error) {
	rows, err := q.db.QueryContext(ctx, searchByDescription, dollar_1)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Search
	for rows.Next() {
		var i Search
		if err := rows.Scan(
			&i.ID,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.Description,
			&i.ArvixUrl,
			&i.ResultsPerFetch,
			&i.LastFetchDate,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateSearch = `-- name: UpdateSearch :one
UPDATE searches
SET 
  updated_at = ?,
  description = ?,
  arvix_url = ?,
  results_per_fetch = ?,
  last_fetch_date = ?
WHERE id = ?
RETURNING id, created_at, updated_at, description, arvix_url, results_per_fetch, last_fetch_date
`

type UpdateSearchParams struct {
	UpdatedAt       time.Time
	Description     string
	ArvixUrl        string
	ResultsPerFetch sql.NullInt64
	LastFetchDate   sql.NullTime
	ID              interface{}
}

func (q *Queries) UpdateSearch(ctx context.Context, arg UpdateSearchParams) (Search, error) {
	row := q.db.QueryRowContext(ctx, updateSearch,
		arg.UpdatedAt,
		arg.Description,
		arg.ArvixUrl,
		arg.ResultsPerFetch,
		arg.LastFetchDate,
		arg.ID,
	)
	var i Search
	err := row.Scan(
		&i.ID,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.Description,
		&i.ArvixUrl,
		&i.ResultsPerFetch,
		&i.LastFetchDate,
	)
	return i, err
}

const updateSearchFetchRate = `-- name: UpdateSearchFetchRate :one
UPDATE searches
SET
  updated_at = ?,
  results_per_fetch = ?
WHERE id = ?
RETURNING id, created_at, updated_at, description, arvix_url, results_per_fetch, last_fetch_date
`

type UpdateSearchFetchRateParams struct {
	UpdatedAt       time.Time
	ResultsPerFetch sql.NullInt64
	ID              interface{}
}

func (q *Queries) UpdateSearchFetchRate(ctx context.Context, arg UpdateSearchFetchRateParams) (Search, error) {
	row := q.db.QueryRowContext(ctx, updateSearchFetchRate, arg.UpdatedAt, arg.ResultsPerFetch, arg.ID)
	var i Search
	err := row.Scan(
		&i.ID,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.Description,
		&i.ArvixUrl,
		&i.ResultsPerFetch,
		&i.LastFetchDate,
	)
	return i, err
}

const updateSearchLastFetchDate = `-- name: UpdateSearchLastFetchDate :one
UPDATE searches
SET
  updated_at = ?,
  last_fetch_date = ?
WHERE id = ?
RETURNING id, created_at, updated_at, description, arvix_url, results_per_fetch, last_fetch_date
`

type UpdateSearchLastFetchDateParams struct {
	UpdatedAt     time.Time
	LastFetchDate sql.NullTime
	ID            interface{}
}

func (q *Queries) UpdateSearchLastFetchDate(ctx context.Context, arg UpdateSearchLastFetchDateParams) (Search, error) {
	row := q.db.QueryRowContext(ctx, updateSearchLastFetchDate, arg.UpdatedAt, arg.LastFetchDate, arg.ID)
	var i Search
	err := row.Scan(
		&i.ID,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.Description,
		&i.ArvixUrl,
		&i.ResultsPerFetch,
		&i.LastFetchDate,
	)
	return i, err
}
