// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: analytics_queries.sql

package database

import (
	"context"
	"database/sql"
	"time"
)

const getCandidateCategoryDistribution = `-- name: GetCandidateCategoryDistribution :many
SELECT 
  cc.arxiv_category,
  COUNT(DISTINCT cc.candidate_id) AS candidate_count
FROM candidate_categories cc
GROUP BY cc.arxiv_category
ORDER BY candidate_count DESC
`

type GetCandidateCategoryDistributionRow struct {
	ArxivCategory  string
	CandidateCount int64
}

func (q *Queries) GetCandidateCategoryDistribution(ctx context.Context) ([]GetCandidateCategoryDistributionRow, error) {
	rows, err := q.db.QueryContext(ctx, getCandidateCategoryDistribution)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetCandidateCategoryDistributionRow
	for rows.Next() {
		var i GetCandidateCategoryDistributionRow
		if err := rows.Scan(&i.ArxivCategory, &i.CandidateCount); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getCandidateDiscoverySource = `-- name: GetCandidateDiscoverySource :many
SELECT 
  c.name as candidate_name,
  a.article_title,
  a.article_url,
  ca.created_at as discovery_date,
  s.description as search_description
FROM candidate_articles ca
JOIN candidates c ON ca.candidate_id = c.id
JOIN articles a ON ca.article_id = a.id
JOIN searches s ON a.search_id = s.id
WHERE ca.candidate_id = ?
ORDER BY ca.created_at DESC
`

type GetCandidateDiscoverySourceRow struct {
	CandidateName     string
	ArticleTitle      string
	ArticleUrl        string
	DiscoveryDate     time.Time
	SearchDescription string
}

func (q *Queries) GetCandidateDiscoverySource(ctx context.Context, candidateID interface{}) ([]GetCandidateDiscoverySourceRow, error) {
	rows, err := q.db.QueryContext(ctx, getCandidateDiscoverySource, candidateID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetCandidateDiscoverySourceRow
	for rows.Next() {
		var i GetCandidateDiscoverySourceRow
		if err := rows.Scan(
			&i.CandidateName,
			&i.ArticleTitle,
			&i.ArticleUrl,
			&i.DiscoveryDate,
			&i.SearchDescription,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getCandidateGrowthOverTime = `-- name: GetCandidateGrowthOverTime :many
SELECT 
  strftime('%Y-%m-%d', c.created_at) AS day,
  COUNT(DISTINCT c.id) AS new_candidates
FROM candidates c
JOIN candidate_searches cs ON c.id = cs.candidate_id
WHERE cs.search_id = ?
GROUP BY day
ORDER BY day
`

type GetCandidateGrowthOverTimeRow struct {
	Day           interface{}
	NewCandidates int64
}

func (q *Queries) GetCandidateGrowthOverTime(ctx context.Context, searchID interface{}) ([]GetCandidateGrowthOverTimeRow, error) {
	rows, err := q.db.QueryContext(ctx, getCandidateGrowthOverTime, searchID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetCandidateGrowthOverTimeRow
	for rows.Next() {
		var i GetCandidateGrowthOverTimeRow
		if err := rows.Scan(&i.Day, &i.NewCandidates); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getMostProductiveSearches = `-- name: GetMostProductiveSearches :many
SELECT 
  s.description,
  s.id,
  COUNT(DISTINCT ca.candidate_id) as discovered_candidates,
  COUNT(DISTINCT a.id) as processed_articles,
  CAST(COUNT(DISTINCT ca.candidate_id) AS FLOAT) / NULLIF(COUNT(DISTINCT a.id), 0) as discovery_rate
FROM searches s
JOIN articles a ON s.id = a.search_id
LEFT JOIN candidate_articles ca ON a.id = ca.article_id
GROUP BY s.id, s.description
HAVING COUNT(DISTINCT a.id) > 0
ORDER BY discovery_rate DESC
LIMIT ?
`

type GetMostProductiveSearchesRow struct {
	Description          string
	ID                   interface{}
	DiscoveredCandidates int64
	ProcessedArticles    int64
	DiscoveryRate        int64
}

func (q *Queries) GetMostProductiveSearches(ctx context.Context, limit int64) ([]GetMostProductiveSearchesRow, error) {
	rows, err := q.db.QueryContext(ctx, getMostProductiveSearches, limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetMostProductiveSearchesRow
	for rows.Next() {
		var i GetMostProductiveSearchesRow
		if err := rows.Scan(
			&i.Description,
			&i.ID,
			&i.DiscoveredCandidates,
			&i.ProcessedArticles,
			&i.DiscoveryRate,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getRecentCandidateDiscoveries = `-- name: GetRecentCandidateDiscoveries :many
SELECT
  c.id as candidate_id,
  c.name as candidate_name,
  a.article_title,
  ca.created_at as discovery_date,
  s.description as search_description
FROM candidate_articles ca
JOIN candidates c ON ca.candidate_id = c.id
JOIN articles a ON ca.article_id = a.id
JOIN searches s ON a.search_id = s.id
ORDER BY ca.created_at DESC
LIMIT ?
`

type GetRecentCandidateDiscoveriesRow struct {
	CandidateID       interface{}
	CandidateName     string
	ArticleTitle      string
	DiscoveryDate     time.Time
	SearchDescription string
}

func (q *Queries) GetRecentCandidateDiscoveries(ctx context.Context, limit int64) ([]GetRecentCandidateDiscoveriesRow, error) {
	rows, err := q.db.QueryContext(ctx, getRecentCandidateDiscoveries, limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetRecentCandidateDiscoveriesRow
	for rows.Next() {
		var i GetRecentCandidateDiscoveriesRow
		if err := rows.Scan(
			&i.CandidateID,
			&i.CandidateName,
			&i.ArticleTitle,
			&i.DiscoveryDate,
			&i.SearchDescription,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getSearchCoverageByCategory = `-- name: GetSearchCoverageByCategory :many
SELECT 
  cc.arxiv_category,
  COUNT(DISTINCT cs.candidate_id) AS candidate_count
FROM candidate_categories cc
JOIN candidate_searches cs ON cc.candidate_id = cs.candidate_id
WHERE cs.search_id = ?
GROUP BY cc.arxiv_category
ORDER BY candidate_count DESC
`

type GetSearchCoverageByCategoryRow struct {
	ArxivCategory  string
	CandidateCount int64
}

func (q *Queries) GetSearchCoverageByCategory(ctx context.Context, searchID interface{}) ([]GetSearchCoverageByCategoryRow, error) {
	rows, err := q.db.QueryContext(ctx, getSearchCoverageByCategory, searchID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetSearchCoverageByCategoryRow
	for rows.Next() {
		var i GetSearchCoverageByCategoryRow
		if err := rows.Scan(&i.ArxivCategory, &i.CandidateCount); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getSearchFetchHistory = `-- name: GetSearchFetchHistory :many
SELECT
  s.id as search_id,
  s.description as search_description,
  a.fetched_at,
  COUNT(a.id) as articles_fetched,
  COUNT(DISTINCT ca.candidate_id) as candidates_discovered
FROM searches s
JOIN articles a ON s.id = a.search_id
LEFT JOIN candidate_articles ca ON a.id = ca.article_id
WHERE s.id = ?
GROUP BY s.id, s.description, DATE(a.fetched_at)
ORDER BY a.fetched_at DESC
`

type GetSearchFetchHistoryRow struct {
	SearchID             interface{}
	SearchDescription    string
	FetchedAt            time.Time
	ArticlesFetched      int64
	CandidatesDiscovered int64
}

func (q *Queries) GetSearchFetchHistory(ctx context.Context, id interface{}) ([]GetSearchFetchHistoryRow, error) {
	rows, err := q.db.QueryContext(ctx, getSearchFetchHistory, id)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetSearchFetchHistoryRow
	for rows.Next() {
		var i GetSearchFetchHistoryRow
		if err := rows.Scan(
			&i.SearchID,
			&i.SearchDescription,
			&i.FetchedAt,
			&i.ArticlesFetched,
			&i.CandidatesDiscovered,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getSearchStatistics = `-- name: GetSearchStatistics :one
SELECT 
  s.id,
  s.description,
  s.arvix_url,
  COUNT(DISTINCT a.id) AS total_articles,
  COUNT(DISTINCT cs.candidate_id) AS total_candidates,
  MIN(a.fetched_at) AS first_fetch_time,
  s.last_fetch_date,
  AVG(cs.relevance_score) AS avg_relevance_score
FROM searches s
LEFT JOIN articles a ON s.id = a.search_id
LEFT JOIN candidate_searches cs ON s.id = cs.search_id
WHERE s.id = ?
GROUP BY s.id, s.description, s.arvix_url, s.last_fetch_date
`

type GetSearchStatisticsRow struct {
	ID                interface{}
	Description       string
	ArvixUrl          string
	TotalArticles     int64
	TotalCandidates   int64
	FirstFetchTime    interface{}
	LastFetchDate     sql.NullTime
	AvgRelevanceScore sql.NullFloat64
}

func (q *Queries) GetSearchStatistics(ctx context.Context, id interface{}) (GetSearchStatisticsRow, error) {
	row := q.db.QueryRowContext(ctx, getSearchStatistics, id)
	var i GetSearchStatisticsRow
	err := row.Scan(
		&i.ID,
		&i.Description,
		&i.ArvixUrl,
		&i.TotalArticles,
		&i.TotalCandidates,
		&i.FirstFetchTime,
		&i.LastFetchDate,
		&i.AvgRelevanceScore,
	)
	return i, err
}

const getTopSearches = `-- name: GetTopSearches :many
SELECT 
  s.id, s.created_at, s.updated_at, s.description, s.arvix_url, s.results_per_fetch, s.last_fetch_date,
  COUNT(DISTINCT cs.candidate_id) AS candidate_count,
  AVG(cs.relevance_score) AS avg_relevance
FROM searches s
LEFT JOIN candidate_searches cs ON s.id = cs.search_id
GROUP BY s.id
ORDER BY candidate_count DESC, avg_relevance DESC
LIMIT ?
`

type GetTopSearchesRow struct {
	ID              interface{}
	CreatedAt       time.Time
	UpdatedAt       time.Time
	Description     string
	ArvixUrl        string
	ResultsPerFetch sql.NullInt64
	LastFetchDate   sql.NullTime
	CandidateCount  int64
	AvgRelevance    sql.NullFloat64
}

func (q *Queries) GetTopSearches(ctx context.Context, limit int64) ([]GetTopSearchesRow, error) {
	rows, err := q.db.QueryContext(ctx, getTopSearches, limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetTopSearchesRow
	for rows.Next() {
		var i GetTopSearchesRow
		if err := rows.Scan(
			&i.ID,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.Description,
			&i.ArvixUrl,
			&i.ResultsPerFetch,
			&i.LastFetchDate,
			&i.CandidateCount,
			&i.AvgRelevance,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}
